---
slug: "/developer-guides/tasks"
description: "This guide introduces the different tasks available in Orkes Conductor and explores the ways to configure a task."
---

# Tasks in Workflows

Tasks are the fundamental building blocks of Conductor workflows. Each task represents a discrete unit of work that can be executed within a larger business process. Understanding how tasks work is essential to building effective workflows in Conductor.

When building workflows, you can use the built-in system tasks and operators provided by Conductor and additionally [write your own custom worker tasks](using-workers) to implement custom logic.

## Built-in tasks

Conductor provides built-in system tasks and operators that let you build workflows without writing custom workers. These are managed by Conductor and run within its JVM (Java Virtual Machine), allowing you to get started quickly.

* [System tasks](/content/category/reference-docs/system-tasks) perform units of work, such as calling APIs, transforming data, or interacting with external services. System tasks include [AI tasks](/category/reference-docs/ai-tasks) that can be used to build AI-powered and agentic applications.
* [Operators](/content/category/reference-docs/operators) control workflow execution, such as branching, looping, and parallel execution.

### Operators

Use these operators as control structures for managing the execution flow in your Conductor workflows.

| Use Case                                                                                     | Task to Use                                                               |
| -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| Conditional flow | <ul><li>[Switch](../reference-docs/operators/switch): Execute tasks conditionally, like an _if…else…_ statement.</li></ul> | 
| Looping flow | <ul><li>[Do While](../reference-docs/operators/do-while): Execute tasks repeatedly, like a _do…while…_ statement.</li></ul> |
| Parallel flows | <ul><li>[Fork](../reference-docs/operators/fork-join): Execute a static number of tasks in parallel.</li><li>[Dynamic Fork](../reference-docs/operators/dynamic-fork): Execute a dynamic number of tasks in parallel.</li><li>[Join](../reference-docs/operators/join): Join the forks after a Fork or Dynamic Fork before proceeding to the next task.</li><li>[Start Workflow](../reference-docs/operators/start-workflow): Asynchronously start another workflow.</li></ul> | 
| Jumps or state changes in flow | <ul><li>[Terminate](../reference-docs/operators/terminate): Terminate the current workflow, like a _return_ statement.</li><li>[Sub Workflow](../reference-docs/operators/sub-workflow): Synchronously start another workflow, like a subroutine.</li><li>[Terminate Workflow](../reference-docs/operators/terminate-workflow.mdx): Terminate another ongoing workflow.</li></ul> | 
| State querying | <ul><li>[Get Workflow](../reference-docs/operators/get-workflow): Get the execution details of another ongoing workflow.</li></ul> | 
| Waits in flow | <ul><li>[Wait](../reference-docs/operators/wait): Pause the current workflow until a set time, duration, or signal is received.</li><li>[Human](/content/reference-docs/operators/human): Pause the current workflow for human input before proceeding to the next task.</li><li>[Yield](../reference-docs/operators/yield): Temporarily yields control over the workflow by pausing the execution until it is explicitly resumed using specific endpoints.</li></ul> | 
| Dynamic tasks in flow | <ul><li>[Dynamic](../reference-docs/operators/dynamic): Execute a task dynamically, like a function pointer.</li></ul> 
| For assigning variables | <ul><li>[Set Variable](../reference-docs/operators/set-variable): Define shared variables at the workflow level that can be accessed or overwritten by subsequent tasks in the workflow.</li></ul> | 

### System tasks 

In most common cases, you can make use of existing Conductor tasks instead of creating a custom worker from scratch. These include tasks for data transformation, user journeys, and LLM chaining.

| Use Case                                                                                     | Task to Use                                                               |
| -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| Publish or consume events                                                                    | [Event](../reference-docs/system-tasks/event)                             |
| Call an API or HTTP endpoint                                                                 | [HTTP](../reference-docs/system-tasks/http)                               |
| Poll an API or HTTP endpoint                                                                 | [HTTP Poll](../reference-docs/system-tasks/http-poll)                     |
| Execute JavaScript scripts                                                                   | [Inline](../reference-docs/system-tasks/inline)                           |
| Clean or transform JSON data                                                                 | [JSON JQ Transform](../reference-docs/system-tasks/jq-transform)                    |
| Evaluate and retrieve data in spreadsheets                                                   | [Business Rule](../reference-docs/system-tasks/business-rule)             |
| Send email using SendGrid integration                                                        | [SendGrid](../reference-docs/system-tasks/sendgrid)                                                              | 
| Pause the current workflow for an incoming webhook signal.                                   | [Wait for Webhook](../reference-docs/system-tasks/wait-for-webhook)
| Modify SQL databases                                                                         | [JDBC](../reference-docs/system-tasks/jdbc)                               |
| Create or update secrets in your Conductor cluster                                           | [Update Secret](../reference-docs/system-tasks/update-secret)  
| Get authorized using a signed JWT                                                            | [Get Signed JWT](../reference-docs/system-tasks/get-signed-jwt)           |
| Update the status of another ongoing task.                                                   | [Update Task](../reference-docs/system-tasks/update-task)                 | 
| Invoke remote endpoints in gRPC services                                                     | [gRPC](../reference-docs/system-tasks/grpc)                               |
| Query data from Conductor Search API or Metrics                                              | [Query Processor](../reference-docs/system-tasks/query-processor)         |
| Send alerts to Opsgenie                                                                      | [Opsgenie](../reference-docs/system-tasks/opsgenie)                       |
| Generate text from an LLM based on a defined prompt                                          | [Text Complete](../reference-docs/ai-tasks/llm-text-complete)             |
| Generate text from an LLM based on a user query and additional system/assistant instructions | [Chat Complete](../reference-docs/ai-tasks/llm-chat-complete)             |
| Generate text embeddings                                                                     | [Generate Embeddings](../reference-docs/ai-tasks/llm-generate-embeddings) |
| Store text embeddings in a vector database                                                   | [Store Embeddings](../reference-docs/ai-tasks/llm-store-embeddings)       |
| Retrieve data from a vector database                                                         | [Get Embeddings](../reference-docs/ai-tasks/llm-get-embeddings)           |
| Chunk, generate, and store text embeddings in a vector database                              | [Index Document](../reference-docs/ai-tasks/llm-index-document)           |
| Retrieve text or JSON content from a URL                                                     | [Get Document](../reference-docs/ai-tasks/llm-get-document)               |
| Generate and store text embeddings in a vector database                                      | [Index Text](../reference-docs/ai-tasks/llm-index-text)                   |
| Retrieve data from a vector database based on a search query                                 | [Search Index](../reference-docs/ai-tasks/llm-search-index)               |
| Divide text into chunks based on the document type                                           | [Chunk Text](../reference-docs/ai-tasks/chunk-text)           |  
| Retrieve files from a specific location                                                      | [List Files](../reference-docs/ai-tasks/list-files)                             |
| Parse and chunk documents from various storage locations                                     | [Parse Document](../reference-docs/ai-tasks/parse-document)                             |

## Custom worker tasks

A [Worker task](../reference-docs/worker-task) can be used to implement custom logic beyond Conductor's built-in tasks. Use custom worker tasks when you need to:

- Integrate with proprietary internal systems or APIs not covered by built-in tasks
- Implement complex business logic specific to your domain
- Execute operations that require access to resources outside Conductor's environment
- Perform computationally intensive processing that benefits from dedicated workers

These tasks can be written in any programming language of your choice (Python, Java, JavaScript, C#, Go, and Clojure). Unlike a built-in task, a Worker task requires setting up a worker outside the Conductor environment that polls for and executes the task. Your worker application will continuously poll Conductor for tasks to execute, process them, and report results back.

Before adding a Worker task in a workflow, it must be registered as a task definition in Conductor. This allows Conductor to apply retries, timeouts, rate limits, and RBAC controls.

Refer to [Writing Workers for Conductor Workflows](/developer-guides/using-workers) for more information.

## Task definitions and task configurations

When working with tasks in Conductor, it's important to understand the distinction between task definitions and task configurations. 

### Task definition

A task definition specifies a task’s general implementation details, such as expected input and output keys, and failure-handling configurations, including rate limits, retries, and timeouts. This definition applies to all instances of the task across workflows.

All task definitions are stored as JSON. These parameters can be updated in real time without needing to redeploy your application. 

Before adding a [Worker task](/content/reference-docs/worker-task) or a [Human task](/content/reference-docs/operators/human) in a workflow, it **must be registered as a task definition** in Conductor. This allows Conductor to apply retries, timeouts, rate limits, and RBAC controls. You may also create a task definition for other system tasks to configure task-specific retry, timeout, rate limit, and other settings.

Task definitions can be registered via the Conductor UI or through SDK/[API](/content/reference-docs/api/metadata/creating-task-definitions). Once registered, they can be referenced and used in different workflows.

**Example**

Here is an example task definition JSON:


``` json
{
  "createTime": 1721901586970,
  "updateTime": 1725926875230,
  "createdBy": "user@acme.com",
  "updatedBy": "user@acme.com",
  "name": "calculate-fx",
  "description": "Calculates currency exchange",
  "retryCount": 0,
  "timeoutSeconds": 3600,
  "inputKeys": [],
  "outputKeys": [],
  "timeoutPolicy": "TIME_OUT_WF",
  "retryLogic": "EXPONENTIAL_BACKOFF",
  "retryDelaySeconds": 30,
  "responseTimeoutSeconds": 600,
  "concurrentExecLimit": 20,
  "inputTemplate": {},
  "rateLimitPerFrequency": 10,
  "rateLimitFrequencyInSeconds": 1,
  "ownerEmail": "user@acme.com",
  "pollTimeoutSeconds": 3600,
  "backoffScaleFactor": 1,
  "enforceSchema": false
}
```

### Task configuration

The task configuration is a task’s configuration details, which are part of the workflow definition. It specifies workflow-specific implementation details, such as the task reference name, task type, and task input parameters.

Although each task type has its unique configuration, all tasks share several parameters in common.

* For all tasks, the configuration specifies the input parameters for the task.
* For custom worker tasks, the configuration contains a reference to a registered worker task definition.
* For system tasks and operators, the configuration includes parameters that control the task behavior. For example, the configuration for an HTTP task specifies the endpoint URL and the payload template, which will be used during task execution.

Refer to the [Task Reference](/category/reference-docs) to learn more about the task configuration for each task type.


### Common configuration parameters

The task configurations appear in the *tasks* array of the workflow definition JSON. For example:

```json
{
 "name": "WorkflowDefinition",
 "description": "Workflow definition",
 "version": 1,
 "tasks": [], // The task configuration appears here 
 "inputParameters": [],
 "outputParameters": {},
 "schemaVersion": 2,
 "restartable": true,
 "workflowStatusListenerEnabled": false,
 "ownerEmail": "john.doe@acme.com",
 "timeoutPolicy": "ALERT_ONLY",
 "timeoutSeconds": 0,
 "failureWorkflow": ""
}
```
Each task configuration JSON object may contain the following parameters:

| Parameter         | Description                                                                                 | Required/ Optional  |
| ----------------- | ------------------------------------------------------------------------------------------- | ------------------- |
| name              | Name of the task. The default value is the same as the task type. <br/><br/>The name can be changed to something descriptive, like “getUsers”. To use a given task definition, the task name here must match the task definition name (case-sensitive).<br/><br/>**Note**: It is recommended to use alphanumeric characters for task names. While special characters are allowed for backward compatibility, they are not fully supported and may cause unexpected behavior. | Required.             |
| taskReferenceName | Reference name for the task. <br/><br/> Must be a unique value in a given workflow.                                                                                                    | Required.           |
| type              | The task type. For example, HTTP, SIMPLE.                                              | Required.           |
| inputParameters   | Map of the task’s input parameters.                                                    | Depends on the task type. |
| optional          | Whether the task is optional. <br/><br/>If set to`true`, any task failure is ignored, and the workflow continues with the task status updated to `COMPLETED_WITH_ERRORS`. However, the task must reach a terminal state. If the task remains incomplete, the workflow waits until it reaches a terminal state before proceeding. | Optional.           |
| asyncComplete     | Whether the task is completed asynchronously. The default value is false. Supported values: <ul><li>**false**: Task status is set to COMPLETED upon successful execution.</li><li>**true**: Task status is kept as IN_PROGRESS until an external event completes it.</li></ul>                                                 | Optional.           |
| startDelay        | The time in seconds to wait before making the task available for worker polling. The default value is 0.                                                                                               | Optional.           |
| onStateChange     | Configuration for publishing an event when the task status changes.                                                                                                 | Optional.           |

## Dealing with data

Conductor provide several mechanisms to pass, validate, and protect data as it moves between tasks. This section covers how to pass data using dynamic references and input templates, mask sensitive values, and enforce schema validation for inputs and outputs.

### Passing data between tasks

Using dynamic references, data can be passed from one task to another. These dynamic references are formatted as JSONPath expressions. Refer to [Wiring Parameters](/content/developer-guides/passing-inputs-to-task-in-conductor) to learn more.

### Passing data using task input templates

Use the task input templates in a task definition to apply default parameters to all instances of the task. Refer to [Using Task Input Templates](/content/developer-guides/task-input-templates) to learn more.

### Masking data in tasks

Masking parameters protect sensitive data from exposure in workflows. It ensures that sensitive values are hidden and not displayed in the workflow definitions or executions. Refer to [Masking Parameters](/content/developer-guides/masking-parameters) to learn more.

### Input/output schema validation

Create schemas to define and enforce the payload structure of workflow or task inputs/outputs. Refer to [Input/Output Schema Validations](/content/developer-guides/schema-validation) to learn more.

## Task reuse

Since task workers typically perform a unit of work as part of a larger workflow, Conductor’s infrastructure is built to enable task reusability out of the box. Once a task is defined in Conductor, it can be reused numerous times:

- In the same workflow, using different task reference names.
- Across various workflows.

When reusing tasks, it's important to consider situations that a multi-tenant system faces. By default, all work assigned to a worker is placed in the same task queue. This could result in your worker not being polled quickly if a noisy neighbor in the ecosystem consumes most of the task queue capacity.
You can address this situation by:
- Scaling up the number of workers to handle the task load
- Using [task-to-domain](/content/developer-guides/task-to-domain) to route the task load into separate queues, providing isolation between different users or projects

## Task lifecycle

Understanding the lifecycle of a task helps you debug and monitor your workflows effectively. Learn more in [Task State Transitions](/content/developer-guides/task-and-workflow-status-in-conductor#task-state-transitions). 

## Common pitfalls to avoid

- Don't reuse the same `taskReferenceName` within a workflow - each instance must have a unique reference.
- Always configure appropriate timeouts and retries in task definitions to prevent workflows from hanging indefinitely.
- Remember that task definitions are shared across workflows, changing retry logic affects all workflows using that task.
- Consider the impact on shared task queues when deploying high-volume workflows.

Learn how to configure input/output parameters to be used in tasks.

```mdx-code-block
import DocCardList from '@theme/DocCardList';

<DocCardList />
```